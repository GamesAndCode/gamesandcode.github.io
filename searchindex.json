[{"section":"Blog","slug":"/blog/objectspawner/","title":"Random position spawning","description":"Learn how to spawn objects on and off the screen in Unity.","date":"October 3, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blog/randomPosition/CoverImage_hu569de8fbc99ac1b63aff186c286b5a91_170323_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"236\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blog\\/randomPosition\\/CoverImage_hu569de8fbc99ac1b63aff186c286b5a91_170323_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blog/randomPosition/CoverImage_hu569de8fbc99ac1b63aff186c286b5a91_170323_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blog\\/randomPosition\\/CoverImage_hu569de8fbc99ac1b63aff186c286b5a91_170323_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Tutorial, Template","tags":"Template, Code, Unity, 2d, spawning, tutorial","content":" Table of Contents Introduction Random position offscreen Random position on screen And now you! Introduction One of the key elements that contributes to the interactivity of a game is the ability to seamlessly spawn objects into the game world. Whether it\u0026rsquo;s an enemy unit stepping out of the shadows, power-ups magically appearing, or obstacles falling from the sky, the art of spawning objects is a fundamental skill for game developers. In this blog post I will explain how to spawn an object at a random position on or off the screen in Unity2D. You can download the code on github or in the download section to follow along.\nRandom position offscreen When developing several 2D games, I always wondered about a good way to spawn objects out of the player\u0026rsquo;s view. Just using a fixed value from the player character did not seem right. What happens if someone plays the game on a different screen resolution? The objects will simply not spawn at the intended location. A better approach is to calculate the screen boundaries and use them as a reference. This can be done using the game camera. With this approach we can set a value that defines the distance at which the object is spawned outside the screen.\nTo get the screen boundaries we can use the main camera. Unfortunately, the edges of our camera do not correspond to the coordinates in our scene, but we can easily transform the edges of the camera into a scene position using the Camera.ScreenToWorldPoint method. The following code snippet demonstrates how to get the edges of our screen and the screen size.\nfloat cameraDistance = mainCamera.nearClipPlane; // Calculate the coordinates of the screen borders BottomLeft = mainCamera.ScreenToWorldPoint(new Vector3(0, 0, cameraDistance)); TopLeft = mainCamera.ScreenToWorldPoint(new Vector3(0, Screen.height, cameraDistance)); TopRight = mainCamera.ScreenToWorldPoint(new Vector3(Screen.width, Screen.height, cameraDistance)); BottomRight = mainCamera.ScreenToWorldPoint(new Vector3(Screen.width, 0, cameraDistance)); Width = BottomRight.x - BottomLeft.x; Height = TopLeft.y - BottomLeft.y; As you can see, we store the values in public fields in order to access them from another class. You can find the code itself in the class ScreenBorders.\nWith this information, we can start calculating a random position on or off the screen. The basic idea is to use Unitys Random class to get a position on one of the screen borders and then move that point an additional distance. For example, if we want to spawn an object from the top of the screen, we can simply calculate a random x-position between two opposite edges. Then we take the y-variable of a top edge and add the distance we want the object to be outside of the screen:\nfloat x = Random.Range(screenBorder.bottomLeft.x, screenBorder.bottomRight.x); float y = screenBorder.topLeft.y + AdditionalDistance; Using this approach, we can decide on which side of the screen to spawn the object. A method that takes the direction as a parameter and returns a random position might look like this:\nprivate Vector2 OutOfScreenDirection(ScreenDirection direction) { screenBorder.CalculateScreenBorders(); float x = Random.Range(screenBorder.BottomLeft.x - AdditionalDistance, screenBorder.BottomRight.x + AdditionalDistance); float y = Random.Range(screenBorder.BottomLeft.y - AdditionalDistance, screenBorder.TopLeft.y + AdditionalDistance); switch (direction) { case ScreenDirection.TOP: y = screenBorder.topLeft.y + AdditionalDistance; break; case ScreenDirection.BOTTOM: y = screenBorder.bottomLeft.y - AdditionalDistance; break; case ScreenDirection.LEFT: x = screenBorder.bottomLeft.x - AdditionalDistance; break; case ScreenDirection.RIGHT: x = screenBorder.bottomRight.x + AdditionalDistance; break; } return new Vector2(x, y); } You will find this method in the class called RandomPosition. The ScreenDirection parameter is a value from an Enum, that defines the direction. To get a random direction including all sides we can write a public method that picks a random direction for us:\npublic Vector2 OutOfScreen() { ScreenDirection[] directions = (ScreenDirection[])Enum.GetValues(typeof(ScreenDirection)); ScreenDirection randomDirection = directions[Random.Range(0, directions.Length)]; return OutOfScreenDirection(randomDirection); } To show the result, I call this method 500 times, spawning some circle objects in a short time:\nRandom position off screen\rThe objects we spawn will all end up at the same distance out of the player\u0026rsquo;s view. A use case for this would be to spawn some enemies that move towards the player.\nAdditionally, we can write a second public method that lets us decide from which direction we get the random position.\npublic Vector2 OutOfScreenDirection(params ScreenDirection[] screenDirections) { ScreenDirection randomSpawnDirection = screenDirections[Random.Range(0, screenDirections.Length)]; return OutOfScreenDirection(randomSpawnDirection); } The params keyword allows us to add a variable number of arguments of type ScreenDirection. This means that we can add multiple direction values as parameters and get a random position from one of them. For example, we might only be interested in getting random positions from left and right. You can see this example in the first image below.\nBy setting the AdditionalDistance variable to a negative value, we can also use this method to get a random position within the screen. You can see this in the second animation.\nUsing following method:\nSpawnOutOfScreen (ScreenDirection.LEFT, ScreenDirection.RIGHT)\rSpawnOutOfScreen (ScreenDirection.TOP) with a negative value\rBefore we go into more detail about onscreen spawning, I want to highlight the current approach we have chosen. The positions we get around the screen border will always have the same distance to the border. As a result, all possible random positions represent a rectangle.If we were to spawn multiple objects with a fixed movement speed at the same time, they would take the same amount of time to enter the player view. But what if we want to spawn objects outside the screen, but all at the same distance from the player?\nFor this approach, we assume that the player is in the center of the screen, as is most often the case in rogue-like games. Using the distance to an edge of the screen as a radius, we can get random positions in a circular shape from the screen. For directions we use the Random class to get an angle corresponding to the direction. For example, the position to the right must be between an angle of -45 to 45. Following the same scheme as we did for the rectangle screen border, we create a new private method: private Vector2 OutOfScreenDirectionCircular(ScreenDirection direction). This method gives us a random position on a circular shape outside the screen. As before, we can specify the directions. The result will look like this:\nRandom position off screen circular\rUsing following method:\nOutOfScreenDirectionCircular (ScreenDirection.LEFT, ScreenDirection.RIGHT)\rTo make it as convenient as possible to switch between rectangle and circle positions, I created a public bool field Circular inside the RandomPosition class. Use this field to toggle between the two random position types.\nI also added a public bool field called SinglePoint. If set to true, the OutOfScreen methods will return only a single point for each direction.The images below illustrate this functionality:\nRandom position off screen:\nSinglePoint = True;\nCircular = False;\rRandom position off screen:\nSinglePoint = True;\nCircular = True;\rThat was a lot of information, so it\u0026rsquo;s best to look at the code yourself. There is a class called Spawner that is associated with a game object in the scene. You can use it to play around with the different methods. If you have any more questions, feel free to ask them in the comments.\nRandom position on screen In the last chapter we already saw how to use a negative AdditonalDistance value to get a position inside the screen with the public Vector2 OutOfScreen() method. Getting a random position on the screen is quite simple compared to the previous methods. We just need to calculate a position between each screen boundary.\npublic Vector2 OnScreen() { screenBorder.CalculateScreenBorders(); return new Vector2(Random.Range(screenBorder.BottomLeft.x, screenBorder.BottomRight.x), Random.Range(screenBorder.BottomLeft.y, screenBorder.TopLeft.y)); } The simulation of this approach looks like this:\nRandom position on screen\rAnother common way to spawn objects is to spawn them around a target, for example the player. Unity\u0026rsquo;s Random class has a method called insideUnitCircle, which returns a random point inside or on a circle with the radius of 1. We can use this method and multipy it with a desired radius. Also we have to add the position of the target.\npublic Vector2 AroundTargetInCircle(GameObject target, float radius) { return (Random.insideUnitCircle * radius) + (Vector2)target.transform.position; } If we want the random position to always have the same distance to the target, we just have to normalize the result of the Random.insideUnitCircle method. This way we always get a Vector2 with a magnitude of 1.\npublic Vector2 AroundTargetOnCircle(GameObject target, float radius) { return (Random.insideUnitCircle.normalized * radius) + (Vector2)target.transform.position; } Both options are shown in the following figures. The white box in the center of the screen symbolizes the target.\nRandom position around the target inside of the circle\rRandom position around the target on the circle\rIn our method AroundTargetInCircle it is possible that objects also appear on the target or directly next to him. However, this is not always intentional. For example, it makes no sense if an enemy spawns right next to the player and the player has no time to react. With a small adjustment in the code we can add a safety distance between the target and the spawn area. So besides the outer radius we need an inner radius that defines the distance. Because the spawnarea now looks like a donut, we also call the method after it:\npublic Vector2 AroundTargetInDonut(GameObject target, float innerRadius, float outerRadius) { Vector2 position = AroundTargetInCircle(target, outerRadius - innerRadius); Vector2 direction = (position - (Vector2)target.transform.position).normalized; return position + direction * innerRadius; } As you can see from the method, we first calculate a random position around the target with the length of our later spawn area. To the resulting point we add the distance of our inner radius. An example can be seen in the following figure:\nRandom position around target\rHaving the random position is a good start, but what now? There are several ways to spawn objects in Unity. The most basic way is to use the instantiate method. Depending on the game you are making, you may want to consider a different approach, such as an object pool. For further reading I recommend an article by gamedevbeginner .\nAnd now you! Get the code template Ask your questions in the comments section. Missing some additional spawn options? Interested in a post about an enemy spawner? "},{"section":"Blog","slug":"/blog/kenneyjampost/","title":"Kenney Jam 2023 recap","description":"My lessons learned from participating in the Game Jam.","date":"September 8, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blog/KenneyJam/KenneyJamLogo_hu2ae239ad31eb85dc654d6dd34ede7829_9686_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"158\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blog\\/KenneyJam\\/KenneyJamLogo_hu2ae239ad31eb85dc654d6dd34ede7829_9686_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blog/KenneyJam/KenneyJamLogo_hu2ae239ad31eb85dc654d6dd34ede7829_9686_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blog\\/KenneyJam\\/KenneyJamLogo_hu2ae239ad31eb85dc654d6dd34ede7829_9686_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Game Jam, Event","tags":"unity, 2d, code, game jam, event","content":" Table of Contents Introduction Game concept First day (Basic implementation) Second day (Look and feel) Third day (Itch.io page and polish) Result Lessons learned And now you! Screenshots Bibliography Introduction Programming a game over a long period of time can be very exhausting. Many indie game developers give up their games during the development process. One reason might be, that the games are too big or too complex to be handled solo.\nGame Jams in contrast, give only a small time period to finish a game. The result might only be a low polished or unfinished game, but there is great potential. Firstly the Game jam forces to think small and not to waste time on every idea, that could be a nice feature. Second, game Jams are a great way to test and enhance your programming and game design skills. Programming is a path of consistent learning. Especially making video games reveals many new aspects to learn every time you do it. Working on a project for a long time sometimes makes you rewrite your initial code because your skills have been already improved again. In conclusion it is sometimes helpful to learn in a smaller project scope.\nTo do that I participated in the KenneyJam 2023. The Jam was 54 hours long and the theme was exploration. It was revealed at the start of the jam. An additional restriction was only to use assets from the organisers website (kenney.nl ). In the following I would like to present the work process of the small space game I created during the jam. You can find my experiences and the full source code at the end of the post.\nGame concept At the start of the jam I first got an overview of the assets. I concluded that using space assets will give a lot of possibilities. Also they are fitting to the theme \u0026ldquo;Exploration\u0026rdquo;. After that, the most important part began. Developing a game idea and committing to it. The difficulty is to find a simple and fun concept that doesn\u0026rsquo;t take too much time to implement. In the book A Theory of Fun, by Raph Koster, it says that games need to train our brain to be fun. The fun comes from richly interpretable situations ([1] p.38).\nTo achieve this, I wanted to combine randomness and resource management. I decided to use two resources that the player would have to manage. Each move would cost a same amount of these resources every time the player moves. At the same time the player gains some resources back, depending on the path he chooses. To avoid boredom when playing the same map over and over again, the amount of resources is generated with a probability at the start of each game.\nThe game idea and the basic game mechanics were born. To reduce complexity I decided to make a 2D game. Next I made some drafts with pen and paper and resulted in a map of a hexagon grid. To prepare the code structure I made a small uml class diagram. The concept took me about 2hours.\nFirst day (Basic implementation) To generate a good looking hexagon map I followed a great tutorial by Game Dev Guide . In order to make this functional for my game, I made some adjustments to generate this for a 2D perspective. This took me some time but in the end I had access to the coordinates of each corner of a hexagon. It was time to use some of the Kenney assets and place them on the grid. So I combined some particle effects to create planets. The result looked like this:\nOn the first day I continued implementing the basic functions. To move the ship, the player has to click on of the neighbouring planets. I decided that every move would cost the player 10 fuel and 5 hull. If one of the resources would reach zero, the game would be over. Each planet will give the player some resources back. The stars have different probabilities to spawn, so that powerful resources are not that common. After adding a user interface, the resource amount was shown, when hovering over the stars. I also added a special star, of which the resources are not shown to the player. It gives either negative or positive stats, based on a coin flip. These risky options give the player the possibility to gamble.\nAt the end of day one the basic game mechanics were finished and the result can be seen in a Twitter post I made that day:\nI managed to create a simple space travel game for the #KenneyJam. Pretty optimistic about finishing it in time!#indiedev #madewithunity pic.twitter.com/9qS2dn8BJZ\n\u0026mdash; Radiant darkness (@RadiantDrk) July 21, 2023 Second day (Look and feel) The second day was about making a better user interface and making the game feel good. For the user interface (UI) I combined some code snippets I already had with game assets from Kenney. This created a spacey looking menu interface.\nThe game assets also include sound effects. I used some of them for the UI buttons and for the movement of the spaceship. I also found some really nice background music at https://opengameart.org/ that added a immersive feeling to the gameplay. For the background I used the unity particle system to spawn some star sprites in front of a background image. These things improved the look and feel.\nAfter playtesting and fixing some bugs, I realized that the gameplay was fun, but not exciting enough. I had a lot of ideas to spice things up, but the second day was almost over.\nTo get the player to play more than one round, I displayed the number of stars traveled, so there could be a personal highscore. To make the player feel even more rewarded, I had to add something else. I had the idea to show some visual effects every time the player reached a certain number of planets traveled. This was not very complicated and could be implemented quickly. I used some more space assets that would slowly fly across the screen after reaching a certain number of points. This ended the second day with a solid basic gameplay. I had a few more ideas, but I planned to use the third day to upload the game and create a nice looking game page on itch.io.\nThird day (Itch.io page and polish) On the third day, I had about eight hours before the deadline. I took my time for the game page and to check if my WebGL version was working correctly. When I finished, I realized that I still had some time left. My game architecture allowed me to implement one more feature without breaking the old stuff. So I added two more spaceships that the player could unlock by reaching a certain number of traveled planets. This gave the game an extra incentive to be played more often. And that was basically it. You can see the final result below.\nResult Game: Space exploration - itch.io. Source code: Github Feedback: Lessons learned Create a game idea that you can execute in the time allotted. It\u0026rsquo;s best to always plan for enough of a buffer. In the end, there is always something left to do. Limit the game idea to as few features as possible. You can always add some afterwards. Organize your tasks into a to-do list. Use pen and paper or online tools. Keep track of your tasks and prioritize them. For example, use Essential, Basic, Nice to Have. You can also estimate how long it will take you to complete each task. For non-essential tasks, it\u0026rsquo;s sometimes even better to set a time limit and keep going, even if you couldn\u0026rsquo;t quite complete the task. Don\u0026rsquo;t forget to add you submission as an extra task. Take the time to make the game feel good. Especially the little things, like sound effects or fade animations already make a big difference. Pay attention to a clean control and avoid game-disrupting bugs. This may be obvious, but once you\u0026rsquo;re in the flow, it\u0026rsquo;s easy to forget to eat something nutritious. At least that was the case for me. Your brain needs a proper meal to function, so don\u0026rsquo;t just eat fast food. The same is true for sleep. It is counterproductive to do without sleep. Your brain works best when you\u0026rsquo;re well-rested. That way you solve problems much better. This is a general tip for programming. If your concentration is slipping or you are stuck on a problem, take a break and move around a bit. The Kenney Jam was optimal for programmers because no additional graphics could be used. For a game jam without this restriction, I recommend at least working with an artist. The collaboration is fun and gives the game a good overall look. Reuse your code! If you already have programming experience, reuse code from old projects. This will speed up the development process. Even if you are implementing a completely new game idea, you can use snippets, such as a game menu or a movement system, from old projects. You can also use my templates that I will provide on this website or on Git. Play a lot of the other submissions. Due to the fact that all participants have the same starting position, the different results are extremely interesting. When playing, pay attention to their game design and what game mechanics were used. Especially fun games are extremely valuable to improve your own understanding of game design. And now you! What has been your experience with Game Jams? Do you have any other tips? Let us know if you plan to attend a game jam and leave it below in the comments! Screenshots Bibliography Koster, Raph. Theory of fun for game design. \u0026quot; O\u0026rsquo;Reilly Media, Inc.\u0026quot;, 2013. "}]